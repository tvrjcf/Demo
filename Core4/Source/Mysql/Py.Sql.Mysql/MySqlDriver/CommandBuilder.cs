// Copyright (C) 2004-2007 MySQL AB
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as published by
// the Free Software Foundation
//
// There are special exceptions to the terms and conditions of the GPL 
// as it is applied to this software. View the full text of the 
// exception in file EXCEPTIONS in the directory of this software 
// distribution.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 

using System;
using System.ComponentModel;
using System.Data.Common;
using System.Data;
using System.Text;
using System.Collections;
using System.Data.Types;
using System.Globalization;

namespace System.Data.MySqlClient
{
    /// <include file='docs/MySqlCommandBuilder.xml' path='docs/class/*'/>
#if !CF
    [ToolboxItem(false)]
    [System.ComponentModel.DesignerCategory("Code")]
#endif
    public sealed class MySqlCommandBuilder : DbCommandBuilder
    {
        private string finalSelect;
        private bool returnGeneratedIds;

        #region Constructors

        /// <include file='docs/MySqlCommandBuilder.xml' path='docs/Ctor/*'/>
        public MySqlCommandBuilder()
        {
            QuotePrefix = QuoteSuffix = "`";
			ReturnGeneratedIdentifiers = true;
        }

        /// <include file='docs/MySqlCommandBuilder.xml' path='docs/Ctor2/*'/>
        public MySqlCommandBuilder(MySqlDataAdapter adapter)
            : this()
        {
            DataAdapter = adapter;
        }

        #endregion

        #region Properties

        /// <include file='docs/mysqlcommandBuilder.xml' path='docs/DataAdapter/*'/>
        public new MySqlDataAdapter DataAdapter
        {
            get { return (MySqlDataAdapter)base.DataAdapter; }
            set { base.DataAdapter = value; }
        }

        private char ParameterMarker
        {
            get
            {
                return (DataAdapter.SelectCommand.Connection as MySqlConnection).ParameterMarker;
            }
        }

        /// <summary>
        /// Indicates whether the command builder should generate a SELECT statement
        /// to populate any autogenerated fields.  We provide this property rather
        /// than rely on the MySqlCommand.UpdatedRowSource property since a user should
        /// still be able to write a custom insert command and not have our work interfere.
        /// </summary>
        public bool ReturnGeneratedIdentifiers
        {
            get { return returnGeneratedIds; }
            set { returnGeneratedIds = value; }
        }

        #endregion

        #region Public Methods

        /// <summary>
        /// Retrieves parameter information from the stored procedure specified 
        /// in the MySqlCommand and populates the Parameters collection of the 
        /// specified MySqlCommand object.
        /// This method is not currently supported since stored procedures are 
        /// not available in MySql.
        /// </summary>
        /// <param name="command">The MySqlCommand referencing the stored 
        /// procedure from which the parameter information is to be derived. 
        /// The derived parameters are added to the Parameters collection of the 
        /// MySqlCommand.</param>
        /// <exception cref="InvalidOperationException">The command text is not 
        /// a valid stored procedure name.</exception>
        public static void DeriveParameters(MySqlCommand command)
        {
            if (!command.Connection.driver.Version.isAtLeast(5, 0, 0))
                throw new MySqlException("DeriveParameters is not supported on MySQL versions " +
                    "prior to 5.0");

            // retrieve the proc definitino from the cache.
            string spName = command.CommandText;
            if (spName.IndexOf(".") == -1)
                spName = command.Connection.Database + "." + spName;
            DataSet ds = command.Connection.ProcedureCache.GetProcedure(command.Connection, spName);

            DataTable parameters = ds.Tables["Procedure Parameters"];
            DataTable procTable = ds.Tables["Procedures"];
            command.Parameters.Clear();
            foreach (DataRow row in parameters.Rows)
            {
                MySqlParameter p = new MySqlParameter();
                p.ParameterName = row["PARAMETER_NAME"].ToString();
                p.Direction = GetDirection(row["PARAMETER_MODE"].ToString(),
                    row["IS_RESULT"].ToString());
                bool unsigned = row["FLAGS"].ToString().IndexOf("UNSIGNED") != -1;
                bool real_as_float = procTable.Rows[0]["SQL_MODE"].ToString().IndexOf("REAL_AS_FLOAT") != -1;
                p.MySqlDbType = MetaData.NameToType(row["DATA_TYPE"].ToString(),
                    unsigned, real_as_float, command.Connection);
                if (!row["CHARACTER_MAXIMUM_LENGTH"].Equals(DBNull.Value))
                    p.Size = (int)row["CHARACTER_MAXIMUM_LENGTH"];
                if (!row["NUMERIC_PRECISION"].Equals(DBNull.Value))
                    p.Precision = (byte)row["NUMERIC_PRECISION"];
                if (!row["NUMERIC_SCALE"].Equals(DBNull.Value))
                    p.Scale = (byte)(int)row["NUMERIC_SCALE"];
                command.Parameters.Add(p);
            }
        }

        private static ParameterDirection GetDirection(string direction, string is_result)
        {
            if (is_result == "YES")
                return ParameterDirection.ReturnValue;
            else if (direction == "IN")
                return ParameterDirection.Input;
            else if (direction == "OUT")
                return ParameterDirection.Output;
            return ParameterDirection.InputOutput;
        }

        /// <summary>
        /// Gets the delete command.
        /// </summary>
        /// <returns></returns>
        public new MySqlCommand GetDeleteCommand()
        {
            return (MySqlCommand)base.GetDeleteCommand();
        }

        /// <summary>
        /// Gets the update command.
        /// </summary>
        /// <returns></returns>
        public new MySqlCommand GetUpdateCommand()
        {
            return (MySqlCommand)base.GetUpdateCommand();
        }

        /// <summary>
        /// Gets the insert command.
        /// </summary>
        /// <returns></returns>
        public new MySqlCommand GetInsertCommand()
        {
            return (MySqlCommand)GetInsertCommand(false);
        }

        /// <include file='docs/MySqlCommandBuilder.xml' path='docs/RefreshSchema/*'/>
        public override void RefreshSchema()
        {
            base.RefreshSchema();
            finalSelect = null;
        }

        /// <summary>
        /// 以正确的目录大小写给定一个不带引号的标识符，返回该标识符的带引号的正确形式，包括正确转义该标识符中嵌入的任何引号。
        /// </summary>
        /// <param name="unquotedIdentifier">不带引号的原始标识符。</param>
        /// <returns>该标识符的带引号的版本。该标识符中嵌入的引号已正确转义。</returns>
        /// <PermissionSet>
        /// 	<IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" PathDiscovery="*AllFiles*"/>
        /// </PermissionSet>
        public override string QuoteIdentifier(string unquotedIdentifier)
        {
            if (unquotedIdentifier == null) throw new
                ArgumentNullException("unquotedIdentifier");

            // don't quote again if it is already quoted
            if (unquotedIdentifier.StartsWith(QuotePrefix) &&
                unquotedIdentifier.EndsWith(QuoteSuffix))
                return unquotedIdentifier;

            unquotedIdentifier = unquotedIdentifier.Replace(QuotePrefix, QuotePrefix + QuotePrefix);

            return String.Format("{0}{1}{2}", QuotePrefix, unquotedIdentifier, QuoteSuffix);
        }

        /// <summary>
        /// 给定一个带引号的标识符，返回该标识符的不带引号的正确形式，包括正确地取消转义该标识符中嵌入的任何引号。
        /// </summary>
        /// <param name="quotedIdentifier">其嵌入引号将被移除的标识符。</param>
        /// <returns>不带引号的标识符，其中嵌入的引号已正确进行取消转义。</returns>
        /// <PermissionSet>
        /// 	<IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" PathDiscovery="*AllFiles*"/>
        /// </PermissionSet>
        public override string UnquoteIdentifier(string quotedIdentifier)
        {
            if (quotedIdentifier == null) throw new
                ArgumentNullException("quotedIdentifier");

            // don't unquote again if it is already unquoted
            if (!quotedIdentifier.StartsWith(QuotePrefix) ||
                !quotedIdentifier.EndsWith(QuoteSuffix))
                return quotedIdentifier;

            if (quotedIdentifier.StartsWith(QuotePrefix))
                quotedIdentifier = quotedIdentifier.Substring(1);
            if (quotedIdentifier.EndsWith(QuoteSuffix))
                quotedIdentifier = quotedIdentifier.Substring(0, quotedIdentifier.Length - 1);

            quotedIdentifier = quotedIdentifier.Replace(QuotePrefix + QuotePrefix, QuotePrefix);

            return quotedIdentifier;
        }

        #endregion


        /// <summary>
        /// 给定部分参数名，返回完整参数名。
        /// </summary>
        /// <param name="parameterName">参数的部分名称。</param>
        /// <returns>对应于所请求的部分参数名的完整参数名。</returns>
        protected override string GetParameterName(string parameterName)
        {
            StringBuilder sb = new StringBuilder(parameterName);
            sb.Replace(" ", "");
            sb.Replace("/", "_per_");
            sb.Replace("-", "_");
            sb.Replace(")", "_cb_");
            sb.Replace("(", "_ob_");
            sb.Replace("%", "_pct_");
            sb.Replace("<", "_lt_");
            sb.Replace(">", "_gt_");
            sb.Replace(".", "_pt_");
            return String.Format("{0}{1}",
                ParameterMarker, sb.ToString());
        }

        /// <summary>
        /// 重置 <see cref="T:System.Data.Common.DbCommand"/> 上的 <see cref="P:System.Data.Common.DbCommand.CommandTimeout"/>、<see cref="P:System.Data.Common.DbCommand.Transaction"/>、<see cref="P:System.Data.Common.DbCommand.CommandType"/> 和 <see cref="T:System.Data.UpdateRowSource"/> 属性。
        /// </summary>
        /// <param name="command">由命令生成器用于对应的 insert、update 或 delete 命令的 <see cref="T:System.Data.Common.DbCommand"/>。</param>
        /// <returns>
        /// 用于每个 insert、update 或 delete 操作的 <see cref="T:System.Data.Common.DbCommand"/> 实例。传入一个 null 值将允许 <see cref="M:System.Data.Common.DbCommandBuilder.InitializeCommand(System.Data.Common.DbCommand)"/> 方法根据与 <see cref="T:System.Data.Common.DbCommandBuilder"/> 关联的 Select 命令创建 <see cref="T:System.Data.Common.DbCommand"/> 对象。
        /// </returns>
        protected override DbCommand InitializeCommand(DbCommand command)
        {
            return base.InitializeCommand(command);
        }


        /// <summary>
        /// 允许 <see cref="T:System.Data.Common.DbCommandBuilder"/> 类的提供程序实现处理附加参数属性。
        /// </summary>
        /// <param name="parameter">要将附加修改应用到的 <see cref="T:System.Data.Common.DbParameter"/>。</param>
        /// <param name="row">来自由 <see cref="M:System.Data.Common.DbDataReader.GetSchemaTable"/> 提供的架构表的 <see cref="T:System.Data.DataRow"/>。</param>
        /// <param name="statementType">生成的命令的类型；INSERT、UPDATE 或 DELETE。</param>
        /// <param name="whereClause">如果参数是 update 或 delete WHERE 子句的一部分，则为 true；如果是 insert 或 update 值的一部分，则为 false。</param>
        protected override void ApplyParameterInfo(DbParameter parameter, DataRow row,
            StatementType statementType, bool whereClause)
        {
            ((MySqlParameter)parameter).MySqlDbType = (MySqlDbType)row["ProviderType"];
        }

        /// <summary>
        /// 以 @p# 格式返回指定参数的名称。在生成自定义命令生成器时使用。
        /// </summary>
        /// <param name="parameterOrdinal">作为参数名的一部分而包含的数字。</param>
        /// <returns>参数名，其中包含作为参数名的一部分而附加的指定数字。</returns>
        protected override string GetParameterName(int parameterOrdinal)
        {
            return String.Format("{0}p{1}", ParameterMarker,
                parameterOrdinal.ToString(CultureInfo.InvariantCulture));
        }

        /// <summary>
        /// 返回该参数在关联的 SQL 语句中的占位符。
        /// </summary>
        /// <param name="parameterOrdinal">作为参数名的一部分而包含的数字。</param>
        /// <returns>附加了指定数字的参数名。</returns>
        protected override string GetParameterPlaceholder(int parameterOrdinal)
        {
            return String.Format("{0}p{1}", ParameterMarker,
                parameterOrdinal.ToString(CultureInfo.InvariantCulture));
        }

        /// <summary>
        /// 注册 <see cref="T:System.Data.Common.DbCommandBuilder"/> 以处理 <see cref="T:System.Data.Common.DbDataAdapter"/> 的 <see cref="E:System.Data.OleDb.OleDbDataAdapter.RowUpdating"/> 事件。
        /// </summary>
        /// <param name="adapter">要用于更新的 <see cref="T:System.Data.Common.DbDataAdapter"/>。</param>
        protected override void SetRowUpdatingHandler(DbDataAdapter adapter)
        {
            if (adapter != base.DataAdapter)
                ((MySqlDataAdapter)adapter).RowUpdating += new MySqlRowUpdatingEventHandler(RowUpdating);
            else
                ((MySqlDataAdapter)adapter).RowUpdating -= new MySqlRowUpdatingEventHandler(RowUpdating);
        }

        private void RowUpdating(object sender, MySqlRowUpdatingEventArgs args)
        {
            base.RowUpdatingHandler(args);

            if (args.StatementType != StatementType.Insert) return;

            if (ReturnGeneratedIdentifiers)
            {
                if (args.Command.UpdatedRowSource != UpdateRowSource.None)
                    throw new InvalidOperationException(
                        System.Data.MySqlClient.Properties.Resources.MixingUpdatedRowSource);
                args.Command.UpdatedRowSource = UpdateRowSource.FirstReturnedRecord;
                if (finalSelect == null)
                    CreateFinalSelect();
            }

            if (finalSelect != null && finalSelect.Length > 0)
                args.Command.CommandText += finalSelect;
        }

        /// <summary>
        /// We only need to return the single auto generated column since the base
        /// ADO.Net classes will take care of mapping it onto the datarow for us.
        /// </summary>
        private void CreateFinalSelect()
        {
            StringBuilder select = new StringBuilder();

            DataTable dt = GetSchemaTable(DataAdapter.SelectCommand);

            foreach (DataRow row in dt.Rows)
            {
                if (!(bool)row["IsAutoIncrement"])
                    continue;

                select.AppendFormat(CultureInfo.InvariantCulture, 
                    "; SELECT last_insert_id() AS `{0}`", row["ColumnName"]);
                break;
            }

            finalSelect = select.ToString();
        }
    }
}
